#version 330 core

layout (location = 0) out vec4 color;

in vec3 vPosition;
in vec3 vNormal;
in vec3 vNormalWorld;
in vec2 vTextureCoords;

struct Material {
    bool ignoreLighting;
};

struct DirectionalLight {
    vec3 color;
    float intensity;
    vec3 direction;
};

struct PointLight {
    vec3 position;
    vec3 color;
    float intensity;
};

uniform vec3 uCameraPosition;

uniform Material uMaterial;
uniform sampler2D uAlbedo;
uniform sampler2D uOcclusionRoughnessMetallic;

uniform vec3 uIrradianceSH[9];
uniform samplerCube uPrefilteredEnvMap;
uniform sampler2D uBRDFLUT;

uniform DirectionalLight uDirectionalLight;
uniform PointLight uPointLights[10];
uniform int uPointLightsCount;

#define PI 3.14159265359
#define PREFILTERED_LEVELS 5

#define saturate(x) clamp(x, 0.0, 1.0)


float distributionGGX(float NoH, float roughness2);
float geometrySchlickGGX(float NoV, float roughness);
vec3 fresnelSchlick(float VoH, vec3 F0);
vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness);
vec3 calculateLight(float NoV, float NoL, float NoH, float VoH, vec3 albedo, float metallic, float roughness2, vec3 F0, vec3 radiance);
vec3 calculateIrradianceSphericalHarmonics(const vec3 normal);


void main() {
    vec4 linearAlbedo = texture(uAlbedo, vTextureCoords);
    if (uMaterial.ignoreLighting) {
        color = linearAlbedo;
        return;
    }

    vec3 albedo = pow(linearAlbedo.rgb, vec3(2.2));
    vec4 occlusionRoughnessMetallic = texture(uOcclusionRoughnessMetallic, vTextureCoords);
    float occlusion = occlusionRoughnessMetallic.r;
    float roughness = occlusionRoughnessMetallic.g;
    float metallic = occlusionRoughnessMetallic.b;

    // common calculations for all lights
    vec3 N = normalize(vNormal);
    vec3 V = normalize(uCameraPosition - vPosition);
    float NoV = saturate(dot(N, V));
    float roughness2 = clamp(roughness * roughness, 1e-3, 1.0);
    // F0 is calculated using the IOR (index of refraction), we approximate it to 0.04 for non-metals and use the albedo for metals
    vec3 F0 = mix(vec3(0.04), albedo, metallic);

    // directional light
    vec3 L = normalize(-uDirectionalLight.direction);
    vec3 H = normalize(V + L);
    float NoL = saturate(dot(N, L));
    float NoH = saturate(dot(N, H));
    float VoH = saturate(dot(V, H));
    vec3 totalLight = calculateLight(NoV, NoL, NoH, VoH, albedo, metallic, roughness2, F0, uDirectionalLight.color * uDirectionalLight.intensity);

    // point lights
    for (int i = 0; i < uPointLightsCount; i++) {
        L = normalize(uPointLights[i].position - vPosition);
        H = normalize(V + L);
        NoL = saturate(dot(N, L));
        NoH = saturate(dot(N, H));
        VoH = saturate(dot(V, H));
        float distance = length(uPointLights[i].position - vPosition);
        float attenuation = 1.0 / (distance * distance);
        vec3 radiance = uPointLights[i].color * uPointLights[i].intensity * attenuation;
        totalLight += calculateLight(NoV, NoL, NoH, VoH, albedo.rgb, metallic, roughness2, F0, radiance);
    }

    // ambient light
    vec3 kS = fresnelSchlickRoughness(max(NoV, 0.0), F0, roughness);
    vec3 kD = 1.0 - kS;
    kD *= 1.0 - metallic;

    vec3 indirectDiffuse = calculateIrradianceSphericalHarmonics(N) * albedo;
    vec3 R = reflect(-V, N);
    vec3 prefilteredColor = textureLod(uPrefilteredEnvMap, R, roughness * (PREFILTERED_LEVELS - 1)).rgb;
    vec2 brdf = texture(uBRDFLUT, vec2(NoV, roughness)).rg;
    vec3 specularIBL = prefilteredColor * (kS * brdf.x + brdf.y);
    vec3 ambient = (kD * indirectDiffuse + specularIBL) * occlusion;

    vec3 finalColor = ambient + totalLight;

    vec3 linearColor = vec3(finalColor);
    linearColor = linearColor / (linearColor + vec3(1.0));
    color = vec4(pow(linearColor, vec3(1.0 / 2.2)), linearAlbedo.a);
}

//
// Lights
//
vec3 calculateLight(float NoV, float NoL, float NoH, float VoH, vec3 albedo, float metallic, float roughness2, vec3 F0, vec3 radiance) {
    vec3 F = fresnelSchlick(VoH, F0);
    float D = distributionGGX(NoH, roughness2);
    float G = geometrySchlickGGX(NoV, roughness2) * geometrySchlickGGX(NoL, roughness2);

    vec3 kD = (1.0 - F) * (1.0 - metallic);
    vec3 diffuse = kD * albedo / PI; // lambert brdf
    vec3 specular = F * G * D / max(4.0 * NoV * NoL, 0.0001); // cook-torrance brdf
    return (diffuse + specular) * radiance * NoL;
}

vec3 calculateIrradianceSphericalHarmonics(const vec3 normal) {
    // band 0
    vec3 sh = uIrradianceSH[0]
    // band 1
    + uIrradianceSH[1] * (normal.y)
    + uIrradianceSH[2] * (normal.z)
    + uIrradianceSH[3] * (normal.x)
    // band 2
    + uIrradianceSH[4] * (normal.y * normal.x)
    + uIrradianceSH[5] * (normal.y * normal.z)
    + uIrradianceSH[6] * (3.0 * normal.z * normal.z - 1.0)
    + uIrradianceSH[7] * (normal.z * normal.x)
    + uIrradianceSH[8] * (normal.x * normal.x - normal.y * normal.y);
    return max(sh, 0.0);
}

// Trowbridge–Reitz (GGX) distribution
float distributionGGX(float NoH, float roughness2) {
    float oneMinusNoH2 = 1.0 - NoH * NoH;
    float a = NoH * roughness2;
    float k = roughness2 / (oneMinusNoH2 + a * a);
    return k * k * (1.0 / PI);
}

// Schlick geometric shadowing/masking approximation
float geometrySchlickGGX(float NoV, float roughness) {
    float a = roughness * roughness;
    float k = a / 2.0;
    return NoV / (NoV * (1.0 - k) + k);
}

// Fresnel-Schlick approximation
vec3 fresnelSchlick(float VoH, vec3 F0) {
    return F0 + (1.0 - F0) * pow(1.0 - VoH, 5);
}

// Fresnel-Schlick approximation with roughness, Sébastien Lagarde implementation
vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

