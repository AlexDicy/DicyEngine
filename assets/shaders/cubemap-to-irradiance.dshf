#version 410 core

layout (location = 0) out vec4 color;

in vec3 v_position;

uniform samplerCube u_environment_map;
uniform vec3 u_ibl_spherical_harmonics[9];

#define PI 3.14159265359

vec3 irradiance_spherical_harmonics(const vec3 normal) {
    vec3 sh = u_ibl_spherical_harmonics[0];
    sh += u_ibl_spherical_harmonics[1] * normal.y;
    sh += u_ibl_spherical_harmonics[2] * normal.z;
    sh += u_ibl_spherical_harmonics[3] * normal.x;
    sh += u_ibl_spherical_harmonics[4] * (normal.y * normal.x);
    sh += u_ibl_spherical_harmonics[5] * (normal.y * normal.z);
    sh += u_ibl_spherical_harmonics[6] * (3.0 * normal.z * normal.z - 1.0);
    sh += u_ibl_spherical_harmonics[7] * (normal.z * normal.x);
    sh += u_ibl_spherical_harmonics[8] * (normal.x * normal.x - normal.y * normal.y);
    return max(sh, vec3(0.0));
}


void main() {
    vec3 normal = normalize(v_position);
    vec3 irradiance = vec3(0.0);
    // original code
    //
    //    vec3 up = vec3(0.0, 1.0, 0.0);
    //    vec3 right = normalize(cross(up, normal));
    //    up = normalize(cross(normal, right));
    //
    //    float sample_delta = 0.025;
    //    float samples = 0.0;
    //    for (float phi = 0.0; phi < 2.0 * PI; phi += sample_delta) {
    //        for (float theta = 0.0; theta < 0.5 * PI; theta += sample_delta) {
    //            // spherical to cartesian (in tangent space)
    //            vec3 tangent_sample = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
    //            // tangent space to world
    //            vec3 sample_vector = tangent_sample.x * right + tangent_sample.y * up + tangent_sample.z * normal;
    //
    //            irradiance += texture(u_environment_map, sample_vector).rgb * cos(theta) * sin(theta);
    //            samples++;
    //        }
    //    }
    //    irradiance = PI * irradiance * (1.0 / float(samples));
    color = vec4(irradiance, 1.0);
}
